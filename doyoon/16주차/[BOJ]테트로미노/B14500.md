## 문제 유형
- 구현
- 브루트포스 알고리즘

## 코드
```java
public static void DFS(int x, int y, int cnt, int sum) {
    if (answer >= sum + max * (4-cnt)) return;
    if (cnt == 4) {
        answer = Math.max(answer, sum);
        return;
    }

    for (int i=0; i<4; i++) {
        int nx = x + dx[i];
        int ny = y + dy[i];
        if (nx < 0 || ny < 0 || nx >= N || ny >= M) continue;
        if (!visit[nx][ny]) {
            visit[nx][ny] = true;
            DFS(nx, ny, cnt + 1, sum + map[nx][ny]);
            DFS(x, y, cnt + 1, sum + map[nx][ny]);
            visit[nx][ny] = false;
        }
    }
}
```

## 로직
1. 현재 재귀 함수가 유망한지 판단하고, 유망하지 않을 경우 반환
2. cnt가 4일 경우, 정답 값을 가장 큰 값으로 갱신
3. 현재 원소 기준으로 상하좌우를 살피면서, 방문하지 않은 노드일 경우 방문 ('ㅗ' 제외한 모양들에 해당)
4. 현재 원소 기준으로 상하좌우를 살피면서, 방문하지 않은 노드의 값을 합치기 ('ㅗ' 모양에 해당)

![img_1.png](img_1.png)

## 리뷰
첫번째 시도에서는 DFS를 한 후, 'ㅗ' 모양에 대해서만 현재 원소 기준으로 상하좌우 확인하여 큰 3개를 선택하여 최댓값을 구하였다.
그러니 시간이 너무 오래걸리고, 메모리도 너무 많이 사용하였다.

두번째 시도에서는 DFS의 깊이를 한단계 낮추었다. 
cnt가 4일때 DFS를 종료하도록 구현하였는데, DFS 함수를 호출할 때 cnt를 1로 지정하여 재귀함수가 더 깊이 안들어가게 하였다.
그러니 메모리 사용량이 반으로 줄었지만, 여전히 시간은 오래 걸렸다.

세번째 시도에서는 백트래킹 방법을 이용하여 유망하지 않은 재귀함수는 반환하도록 하였다.
map에 있는 원소 중 가장 큰 수를 max에 저장해놓고, 매번 재귀함수를 호출할 때마다 answer 값과 비교하여 유망하지 않으면 더 이상 재귀호출 하지 않도록 하였다.
그러니 시간이 반으로 줄었다.

조금만 더 관심있고 세심하게 코드를 들여다봐서 시간과 메모리를 줄일 수 있도록 연습해야겠다.